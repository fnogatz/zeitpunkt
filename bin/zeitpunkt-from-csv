#!/usr/bin/env node

var fs = require('fs')
var program = require('commander')
var spinner = require('char-spinner')
var geobuf = require('geobuf')
var csv = require('csv')
var concat = require('concat-stream')
var turf = {
  linestring: require('turf-linestring')
}

spinner()

program
  .usage('[options] <csv>')
  .option('--points <points>', 'Manually split trajectories at number of points', parseInt)
  .option('--delimiter <char>', 'Column delimiter (default: ",")')
  .option('--cols <columns>', 'List of columns (default: "id,date,lon,lat')
  .option('--ignore <rows>', 'Ignore first rows (default: 0)')
  .option('--lat <bounds>', 'Set bounds for latitude (default: "-90,90")')
  .option('--lon <bounds>', 'Set bounds for longitude (default: "-180,180")')
  .option('--eps <number>', 'Epsilon (default: 0.001)')
  .option('-a, --array', 'Export as JSON Array instead of newline-separated datasets')
  .option('-b, --geobuf', 'Export as Geobuf')
  .option('-i, --indentation <spaces>', 'Set indentation level (default: 0)', parseInt)
  .parse(process.argv)

program.indentation = program.indentation === undefined ? 0 : program.indentation
var filename = program.args[0]

function print (obj) {
  if (program.geobuf) {
    var buf = geobuf.featureToGeobuf(obj)
    process.stdout.write(buf.encode().toBuffer())
    return
  }

  console.log(JSON.stringify(obj, null, Array(program.indentation + 1).join(' ')))
}

transform(filename, program)

function transform (filename, options) {
  options = options || {}
  options.ignore = options.ignore || 0
  options.eps = options.eps || 0.001
  options.bounds = options.bounds || {}
  options.bounds.lat = options.bounds.lat || [-90, 90]
  options.bounds.lon = options.bounds.lon || [-180, 180]
  options.indentation = (options.hasOwnProperty('indentation') ? options.indentation : 2)
  options.cols = options.cols || 'id,date,lon,lat'
  options.columns = options.cols.split(/[,;]/)

  loadCSV(filename, options, function (rows) {
    rows = rows.slice(options.ignore)

    var rowsLength = rows.length
    var chunk
    var linestring
    var row, lon, lat, prevLon, prevLat, prevDate
    var coords = []
    var times = []

    for (var i = 0; i < rowsLength; i++) {
      row = rows[i]

      lon = parseFloat(row.lon)
      lat = parseFloat(row.lat)

      if (lon < options.bounds.lon[0] || lon > options.bounds.lon[1]) {
        continue
      }
      if (lat < options.bounds.lat[0] || lat > options.bounds.lat[1]) {
        continue
      }

      if (row.date === prevDate) {
        continue
      }

      if (epsNear(lon, prevLon, options.eps) && epsNear(lat, prevLat, options.eps)) {
        continue
      }

      coords.push([ lon, lat ])
      times.push(new Date(row.date).getTime())

      prevLon = lon
      prevLat = lat
      prevDate = row.date
    }

    if (options.points) {
      var entities = times.length
      for (var k = 0; k < entities; k += options.points) {
        chunk = {
          times: times.slice(k, k + options.points),
          coords: coords.slice(k, k + options.points)
        }

        linestring = turf.linestring(chunk.coords, {
          time: chunk.times,
          id: rows[0].id + '-' + k
        })
        print(linestring)
      }
    } else {
      linestring = turf.linestring(coords, {
        time: times,
        id: rows[0].id
      })
      print(linestring)
    }
  })
}

function epsNear (a, b, eps) {
  return Math.abs(a - b) <= eps
}

function loadCSV (filename, options, callback) {
  fs.createReadStream(filename)
    .pipe(csv.parse(options))
    .pipe(concat(callback))
}
